<!doctype html><html lang=es-mx><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Notas acerca de «Clean Code» de Robert C. Martin</title><link rel=stylesheet media=screen href=https://joshua.haase.mx/css/theme.min.2ee1317322f9eb9b2ef0a618d19b20e38c11f5f9c310751400a45db225dd2626.css integrity="sha256-LuExcyL565su8KYY0Zsg44wR9fnDEHUUAKRdsiXdJiY="><script src=https://hypothes.is/embed.js></script></head><body><main><article><h1>Notas acerca de «Clean Code» de Robert C. Martin</h1><nav id=TableOfContents></nav><p>El problema es que perdemos efectividad conforme avanzamos en el proyecto.</p><p>El buen código:</p><ul><li>Se lee como prosa.</li><li>Es elegante.</li><li>Es efectivo.</li><li>Puede mantenerlo alguien que no lo escribió.</li><li>Hace una única cosa bien.</li><li>Ejecuta todas las pruebas.</li><li>No contiene duplicados.</li><li>Expresa los conceptos del sistema.</li><li>Mínimo.</li></ul><blockquote><p>Parece escrito por alguien a quién le importa.</p></blockquote><hr><p>Nombres con significado.</p><ul><li>Expresan los conceptos del sistema (getThem(List) → getFlaggedCells(gameboard)).</li><li>Evitar palabras superfluas.</li></ul><hr><p>Funciones</p><p>Puede evaluarse el enfoque de una función si puede describirse como</p><blockquote><p>Para [nombre_de_función], [descripción de lo que hace la función].</p></blockquote><p>Si la descripción tiene elementos que no corresponden al nombre está mal.</p><p>Evitar esfuerzo cognitivo.</p><p>Devolver errores fuerza a procesarlos inmediatamente,
el procesamiento de errores es su propia función.
Es preferible activar una excepción.</p><hr><p>Comentarios</p><blockquote><p>No comente el código incorrecto, reescríbalo.</p></blockquote><hr><p>Formato</p><p>Es más importante ser consistente que atender preferencias personales.</p><p>El formato debe facilitar entender la estructura del código.</p><hr><p>Estructura de datos</p><p>Los objetos muestran comportamiento y ocultan datos.</p><p>La estructuras de datos muestran datos y carecen de comportamiento.</p><hr><p>Manejo de errores</p><p>Es aconsejable encapsular código de terceros
(incluyendo los erores).</p><p>Desplazar el código de detección de errores hacia los bordes del programa.</p><p>Nunca devolver NULL.</p><hr><p>Límites:</p><p>Envolver los NULL con objetos de caso especial.</p><p>Se pueden hacer pruebas para aprender cómo funciona cóndgo externo
y esas pruebas nos alertan si cambia la interfaz.</p><p>Envolver el código de tercero y referenciarlo en puntos mínimos
(los bordes del sistema).</p><hr><p>Pruebas unitarias</p><p>Las pruebas permiten cambiar el código con confianza.</p><p>Las pruebas deben diseñarse para ser limpias.</p><p>Las pruebas guían el desarrollo de la API.</p><blockquote><p>GIVEN [input], [component] MUST [action].</p></blockquote><p>Las pruebas deben ser:</p><p>Fast
Independent
Repeatable
Self-verifying
Timely</p><hr><p>Clases</p><p>Deben ser reducidas (más reducidas que eso).</p><p>Las clases deben tener una única «Responsabilidad».</p><p>Single Responsability Principle
Open/Closed Principle
Liskov Substitution Principle
Interface Segregation Principle
Dependency Inversion Principle:
~ Las clases dependen de abstracciones, no de detalles concretos.</p><hr><p>Sistemas:</p><p>› Ejemplo de ciudades como sistemas.</p><p>Inversión del control:</p><p>~ un objeto no debe ser responsable de las dependencias
sino delegar la responsabilidad a un método autorizado
(p.e. la rutina <code>main</code>).</p><p>Usar objetos simples para hacer el trabajo,
e inyectar dependencias en los bordes.</p><p>Un buen sistema está preparado para evolucionar.
En vez de diseñar todo al inicio,
simplificar los componentes y
permitir postponer decisiones.</p><hr><p>Diseñar sistemas emergentes</p><p>Reglas de diseño simple de Kent Beck [@isbn:9780321278654]:</p><ul><li>Ejecuta todas las pruebas</li><li>No contiene duplicados</li><li>Expresa la intención en el lenguaje del dominio</li><li>Minimiza el número de clases y métodos</li></ul><hr><p>Concurrencia</p><p>Separar el código de concurrencia del resto del código.</p><p>Usar un único método en objetos compartidos.</p><p>Los procesos de cierre son problemáticos.</p><p>Pruebas en diferentes configuraciones.</p><p>Verificar que el código funciona fuera de los procesos.</p><p>Ejecutar más procesos que procesadores.</p><p>Ejecutar en diferentes plataformas.</p><p>Para encontrar errores
es importante instrumentar el código.</p><hr><p>Refinamiento sucesivo</p><p>Usar las pruebas para siempre mantener el funcionamiento.</p><p>Regla del Boy Scout: dejar el código más limpio que cómo lo encontramos.</p><hr><p>Síntomas y heurística</p><p>[@ refactoring—martin Fowler]</p><p>Contiene varias heurísticas para detectar código malo.</p><p>Usar importaciones de comodín en vez de importaciones estáticas.</p></article></main></body></html>