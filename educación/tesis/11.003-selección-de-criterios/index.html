<!doctype html><html lang=es-mx><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Joshua Haase</title>
<link rel=stylesheet media=screen href=https://joshua.haase.mx/css/theme.min.2ee1317322f9eb9b2ef0a618d19b20e38c11f5f9c310751400a45db225dd2626.css integrity="sha256-LuExcyL565su8KYY0Zsg44wR9fnDEHUUAKRdsiXdJiY="></head><body><main><article><nav id=TableOfContents><ul><li><a href=#proyecto-a-futuro>Proyecto a futuro</a></li><li><a href=#estándar-para-la-organización-del-proyecto>Estándar para la organización del proyecto</a></li><li><a href=#registros-en-git>Registros en Git</a></li></ul></nav><h1 id=selección-de-criterios-candidatos-a-evaluación-automática><a href=#selecci%c3%b3n-de-criterios-candidatos-a-evaluaci%c3%b3n-autom%c3%a1tica alt>Selección de criterios candidatos a evaluación automática</a> <a href=# alt="Regresar al inicio">↑</a></h1><p>Esta lista de errores comunes puede revisarse a partir de una respuesta correcta
con una prueba unitaria.</p><p>Estos errores no están relacionados con el estilo de código,
pero por su frecuencia y simplicidad de implementación de la automatización,
permiten implementarse de manera sencilla.</p><ul><li>Tipo de variable incorrecto</li><li>Falta de la sentencia para devolver la variable.</li><li>Error de desbordamiento de buffer</li><li>Error por uno</li><li>La variable está llamada por valor y no por referencia</li></ul><p>Categorización de criterios criterios:</p><p>1). Se puede revisar automáticamente.</p><p>2). No se puede revisar automáticamente.</p><p>3). Debería ser posible, pero se necesita más investigación.</p><h2 id=proyecto-a-futuro><a href=#proyecto-a-futuro alt>Proyecto a futuro</a> <a href=# alt="Regresar al inicio">↑</a></h2><p>El alumno presenta en su proyecto los siguientes elementos <sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>:</p><ul><li><p>Levantamiento de requerimiento (8 pasos)</p></li><li><p>Diagrama de entradas, procesos y salidas</p></li><li><p>Diagrama de flujo (opcional)</p></li><li><p>Pseudocódigo (repositorio de git)</p></li><li><p>Pruebas de escritorio</p></li></ul><p>El programa usa el estilo K&amp;R. <sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup></p><ul><li>El programa indent puede corregir el estilo
pero se puede un script que únicamente revise.</li></ul><p>El alumno puede identificar y corregir código donde las únicas fallas sean <sup id=fnref1:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup>:</p><ul><li>Tipo de variable incorrecto.</li><li>Falta de la sentencia para devolver la variable.</li><li>Error de desbordamiento de buffer.</li><li>Error por uno.</li><li>La variable está llamada por valor y no por referencia.</li></ul><p>Identificación de variables (sustantivos) <sup id=fnref1:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>.</p><ul><li>Las variables usadas en el programa utilizan el lenguaje de la declaración del problema. (Un diccionario del dominio del problema)</li><li>Los nombres de las variables no dan información acerca de la implementación. (Un diccionario de palabras del lenguaje)</li></ul><p>Identificación de funciones (verbos) <sup id=fnref2:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>.</p><ul><li><p>Las funciones usadas en el programa utilizan el lenguaje de la declaración del problema. (Un diccionario del dominio del problema)</p></li><li><p>Los nombres de las funciones no dan información acerca de la implementación. (Un diccionario de palabras del lenguaje)</p></li><li><p>Declaración de constantes (mayúsculas).</p></li><li><p>Todos los DEFINE y const van en mayúsculas <sup id=fnref:3><a href=#fn:3 class=footnote-ref role=doc-noteref>3</a></sup>.</p></li><li><p>Identificar el estilo de declaración de variables, constantes y funciones.</p></li></ul><h2 id=estándar-para-la-organización-del-proyecto><a href=#est%c3%a1ndar-para-la-organizaci%c3%b3n-del-proyecto alt>Estándar para la organización del proyecto</a> <a href=# alt="Regresar al inicio">↑</a></h2><p>La estructura de los proyectos sigue el siguiente estándar <sup id=fnref1:3><a href=#fn:3 class=footnote-ref role=doc-noteref>3</a></sup>:</p><ul><li>Cada función se declara en un archivo diferente “.c”.
Existe al menos un directorio para alojar las funciones del programa.
Se genera un archivo “.h” para declarar las funciones de cada directorio.
El makefile declara el directorio para vincular la biblioteca generada.
El makefile compila el proyecto correctamente con gcc.</li></ul><p>Ventajas</p><ul><li><p>Se genera de manera orgánica bibliotecas reusable.</p></li><li><p>Esta organización permite incluir objetos individualmente según se usen. (p.e. cargar la biblioteca para usar una única función no implica vincular los diez objetos que conforman la biblioteca).</p></li></ul><p>Desventajas</p><ul><li><p>Hay muchos archivos por cada programa.</p></li><li><p>Pueden estar desorganizados.</p></li><li><p>La categorización de las bibliotecas es arbitraria y no puede evaluarse automáticamente</p></li><li><p>Puede generar frustración y recelo por C o programar por el sobre trabajo que estos requisitos solicitan.</p></li><li><p>No deben existir definiciones de variables globales.</p></li><li><p>Se genera a partir del código la documentación del código al pasar por doxygen.
La documentación describe adecuadamente el código (no se puede evaluar automáticamente).
Podrían usarse test cases en doxygen para evaluar esto, si doxygen lo admite.</p></li></ul><h2 id=registros-en-git><a href=#registros-en-git alt>Registros en Git</a> <a href=# alt="Regresar al inicio">↑</a></h2><p>Esta es un área muy importante para garantizar que el código es mantenible
y para permitir una adecuada revisión de los cambios.</p><p>Desafortunadamente, es un área que muy posiblemente sería imposible de evaluar
de manera automática, salvo tal vez con la aplicación de algoritmos de aprendizaje de máquina,
y aún así las conclusiones deberían ser supervisadas por una persona
para asegurarse de la calidad de la revisión.</p><p>Un buen historial de git <sup id=fnref2:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup>:</p><ul><li>Tiene un commit por cada avance. (Un proxy para esto sería un número aproximado de commits dependiendo de la magnitud del proyecto).</li><li>Describe lo que se hizo en el commit.</li><li>Explica por qué se hacen los cambios si es necesario.</li><li>Tiene pocas líneas para revisar (se puede usar un número arbitrario de líneas agregadas, sin límite para eliminadas).</li></ul><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p>No se puede revisar automáticamente.&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a>&#160;<a href=#fnref1:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a>&#160;<a href=#fnref2:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2><p>Se puede revisar automáticamente.&#160;<a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a>&#160;<a href=#fnref1:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a>&#160;<a href=#fnref2:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:3><p>Debería ser posible, pero se necesita más investigación.&#160;<a href=#fnref:3 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a>&#160;<a href=#fnref1:3 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></article></main></body></html>