<!doctype html><html lang=es-mx><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Una exploración del análisis binario</title><link rel=stylesheet media=screen href=https://joshua.haase.mx/css/theme.min.2ee1317322f9eb9b2ef0a618d19b20e38c11f5f9c310751400a45db225dd2626.css integrity="sha256-LuExcyL565su8KYY0Zsg44wR9fnDEHUUAKRdsiXdJiY="><script src=https://hypothes.is/embed.js></script></head><body><main><article><h1>Una exploración del análisis binario</h1><nav id=TableOfContents><ul><li><a href=#cómo-compilar-para-hacer-demostraciones-de-seguridad>Cómo compilar para hacer demostraciones de seguridad</a></li><li><a href=#llamadas-de-sistema>Llamadas de sistema</a></li><li><a href=#herramientas-para-analizar-binarios>Herramientas para analizar binarios</a></li><li><a href=#radare>Radare</a><ul><li><a href=#cuando-haces-exploración-con-r2-de-un-binario-estas-funciones-son-útiles>Cuando haces exploración con r2 de un binario estas funciones son útiles</a></li></ul></li><li><a href=#una-interfaz-gráfica-te-permite-conservar-el-regalo-de-la-ignorancia>Una interfaz gráfica te permite conservar el regalo de la ignorancia</a></li></ul></nav><p>Lo primero que es importante para revisar binarios es <a href=https://www.nand2tetris.org/ target=_blank rel=noopener>saber cómo funciona una computadora</a>.
y por eso te recomiendo leer este libro:</p><p><a href=https://www.nand2tetris.org/book target=_blank rel=noopener><figure><img src=https://static.wixstatic.com/media/44046b_68deee3a58e64efdba36a6813c4ea906~mv2.png/v1/crop/x_73,y_0,w_663,h_654/fill/w_510,h_502,al_c,q_85,usm_0.66_1.00_0.01/44046b_68deee3a58e64efdba36a6813c4ea906~mv2.webp><figcaption>El libro que muestra cómo desarrollar una computadora desde cero</figcaption></figure></a>.</p><p>Luego es importante entender el ciclo del CPU:</p><ul><li><p><a href='https://www.youtube.com/watch?v=Y4O2-ilSw-o' target=_blank rel=noopener>Fetch-Decode-Execute</a>.</p><p>Me gusta <a href>este simulador de CPU donde puedes escribir programas sencillos</a></p></li></ul><p>Y por último es necesario:</p><ul><li><p>Tener una intuición de <a href=https://www.tutorialspoint.com/assembly_programming/assembly_tutorial.pdf target=_blank rel=noopener>qué hacen las operaciones en ensamblador</a>.</p><p><a href=https://www.secjuice.com/guide-to-x86-assembly/ title="A Guide To x86 Assembly" target=_blank rel=noopener>Esta introducción al ensamblador explica</a>:</p><ul><li>cómo acceder a los registros y sus fracciones para <code>x86</code></li><li>cómo entender las llamadas a sistema (modo obsoleto para x86 que sigue funcionando en <code>x64</code> pero es lento).</li></ul><p><a href=https://www.tutorialspoint.com/assembly_programming/assembly_tutorial.pdf target=_blank rel=noopener>Este tutorial de ensamblador que se ve bastante bueno</a>.</p><p><a href=https://www.nayuki.io/page/a-fundamental-introduction-to-x86-assembly-programming target=_blank rel=noopener>Puedes leer aquí conceptos básicos</a></p></li><li><p>Leer informacion en hexadecimal.</p></li><li><p>Tener una intuición para ubicar valores ASCII.</p></li><li><p>Conviene entender las llamadas a sistema.</p></li><li><p>Conviene <a href=/techno/gdb/>saber usar tu depurador de código</a>,
pero no será suficiente si no tienes los símbolos del sistema.</p></li></ul><h2 id=cómo-compilar-para-hacer-demostraciones-de-seguridad><a href=#c%c3%b3mo-compilar-para-hacer-demostraciones-de-seguridad alt>Cómo compilar para hacer demostraciones de seguridad</a> <a href=# alt="Regresar al inicio">↑</a></h2><p><a href=https://security.stackexchange.com/questions/72653/exploiting-buffer-overflow-leads-to-segfault target=_blank rel=noopener>Las banderas que pueden usarse para permitir la explotación de binarios</a>:</p><ul><li><code>-no-pie</code></li><li><code>-z execstack</code></li><li><code>-Wl,-z,norelro</code></li><li><code>-fno-stack-protector</code></li><li><code>-g</code></li><li><code>-mpreferred-stack-boundary=2</code></li></ul><p><a href=https://www.jerkeby.se/newsletter/posts/history-of-rop/ target=_blank rel=noopener>Los siguientes métodos causan problemas incluso en una pila de sólo lectura</a>:</p><pre><code>-   buffer overflow
-   Integer overflow,
-   heap based overflows,
-   double free and
-   null pointer dereference
</code></pre><h2 id=llamadas-de-sistema><a href=#llamadas-de-sistema alt>Llamadas de sistema</a> <a href=# alt="Regresar al inicio">↑</a></h2><p><a href=http://asm.sourceforge.net/syscall.html target=_blank rel=noopener>Las instrucciones básicas del sistema operativo tienen un número asignado</a>.</p><p>Y el lugar de memoria (incluyendo registros del CPU)
en que se procesan los argumentos está influenciado por:</p><ul><li>La arquitectura del CPU,</li><li><a href>la convención de llamadas a sistema</a>,</li><li>[la forma específica en que se implementan las llamadas a función](
en tu lenguaje (o el lenguaje en que se programó tu lenguaje, generalmente C).</li></ul><h2 id=herramientas-para-analizar-binarios><a href=#herramientas-para-analizar-binarios alt>Herramientas para analizar binarios</a> <a href=# alt="Regresar al inicio">↑</a></h2><ul><li><a href=https://opensource.com/article/19/10/gnu-binutils target=_blank rel=noopener><code>binutils</code></a></li><li><a href=https://rada.re/n/radare2.html target=_blank rel=noopener><code>radare</code></a></li></ul><h2 id=radare><a href=#radare alt>Radare</a> <a href=# alt="Regresar al inicio">↑</a></h2><p>Este es el proceso que sigo cuando quiero analizar un binario con <code>radare</code>
y lo tengo aquí en parte porque</p><ol><li><p>Analizar toda la información del binario</p><pre tabindex=0><code>r2 -A ${BINARIO}
</code></pre></li><li><p>Buscar la función</p><pre tabindex=0><code>s ${FUNCION}
</code></pre></li><li><p>Mostrar qué hace la función</p><pre tabindex=0><code>pdf
pdf@${FUNCION}
</code></pre></li><li><p>Visualizar función</p><pre tabindex=0><code>VV
VV@${FUNCION}
</code></pre></li></ol><p>Cuando usas los páneles textuales puedes usar <code>&lt;tab></code> para moverse entre nodos.</p><h3 id=cuando-haces-exploración-con-r2-de-un-binario-estas-funciones-son-útiles><a href=#cuando-haces-exploraci%c3%b3n-con-r2-de-un-binario-estas-funciones-son-%c3%batiles alt>Cuando haces exploración con r2 de un binario estas funciones son útiles</a> <a href=# alt="Regresar al inicio">↑</a></h3><p>Renombrar funciones:</p><pre tabindex=0><code>afv
</code></pre><p>Renombrar variables:</p><pre tabindex=0><code>afvn
</code></pre><h2 id=una-interfaz-gráfica-te-permite-conservar-el-regalo-de-la-ignorancia><a href=#una-interfaz-gr%c3%a1fica-te-permite-conservar-el-regalo-de-la-ignorancia alt>Una interfaz gráfica te permite conservar el regalo de la ignorancia</a> <a href=# alt="Regresar al inicio">↑</a></h2><p>La verdad es que una herramienta con una interfaz tan horrible
tal vez no merece espacio de sinapsis neuronales
a menos que tengas que usarlo muy comunmente.</p><p>Una interfaz gráfica para usarlo
puede permitir hacer cosas
antes de saber los comandos.</p><p>Las interfaces que conozco para estos programas son:</p><ul><li><p><code>iaito</code>: esta interfaz me dio problemas al actualizar en Arch,
pero tal vez podría funcionarte.</p></li><li><p><a href=https://cutter.re/ title="No recuerdo si uso radare" target=_blank rel=noopener><code>cutter</code></a>: esta es la que yo uso.</p></li></ul></article></main></body></html>